from config import db, ph
from database.enums import Roles, LogTypes, FuelTypes
from flask_login import UserMixin
import database.neso_api as neso
import datetime
import random
from argon2.exceptions import VerifyMismatchError, VerificationError
import sqlalchemy
import math
import json

### NOTE: Whilst this module is named 'tables', these are actually Flask-SQLAlchemy Models

#User database table class
class User(db.Model, UserMixin):
    #__table__ = db.metadata.tables['user']
    __tablename__ = "user"

    user_id = db.Column(db.Integer, primary_key=True, nullable=False)#, unsigned=True, unique=True)
    username = db.Column(db.String(45), unique=True, nullable=False)
    email = db.Column(db.String(60), unique=True, nullable=False)
    address_id = db.Column(db.Integer, db.ForeignKey('address.address_id'), nullable=True)
    password = db.Column(db.String(60), nullable=False)
    ecopoints = db.Column(db.Integer, nullable=False)#, unsigned=True)
    first_name = db.Column(db.String(45), nullable=True)
    last_name = db.Column(db.String(45), nullable=True)
    role = db.Column(db.Enum(Roles), nullable=False)
    last_login = db.Column(db.DateTime, nullable=True)
    mfa_key = db.Column(db.String(32), nullable=True)
    mfa_enabled = db.Column(db.Boolean, nullable=False)
    email_verified = db.Column(db.Boolean, nullable=False)
    verification_email_sent = db.Column(db.Boolean, nullable=False)

    #user_id - Unique user id, generated by the app at user creation
    #username - Unique username
    #email - Unique email
    #password - encrypted password hash - THIS SHOULD ALREADY BE ENCRYPTED BY User.encrypt_password()
    #role - either user or admin, see database.Roles
    ## OPTIONAL ARGUMENTS - Define by using `argument_name = [argument_value]` (e.g. first_name='Steve')
    #ecopoints - Integer number of ecopoints to grant the user at creation. Defaults to 0 if unspecified
    #first_name - User's first name
    #last_name - User's last name
    def __init__(self, username, email, password, role, mfa_key, mfa_enabled, **kwargs):
        self.user_id = self.generate_id()
        self.username = username
        self.email = email
        self.password = password
        self.role = role
        self.ecopoints = int(kwargs.get('ecopoints', 0))
        self.first_name = kwargs.get('first_name', None)
        self.last_name = kwargs.get('last_name', None)
        self.last_login = datetime.datetime.now()
        self.mfa_key = mfa_key
        self.mfa_enabled = mfa_enabled
        self.email_verified = False
        self.verification_email_sent = False
    
    def is_admin(self):
        return self.role == Roles.admin

    #Returns user_id. Needed for flask_login implementation
    def get_id(self):
        return str(self.user_id)

    #Generates a random unique 32-bit integer ID.
    #Automatically looks up if ID in database, and re-generates if already exists
    #Generates a random unique 32-bit integer ID.
    #Automatically looks up if ID in database, and re-generates if already exists
    @staticmethod
    def generate_id():
        while True:
            new_id = random.randint(128,2147483646)
            if User.query.filter_by(user_id=new_id).first():
                continue
            break

        return new_id

    #Function to automatically encrypt a user's password
    #Run directly on user input; do not store unencrypted password in any variables
    @staticmethod
    def encrypt_password(password):
        hashed_pass = ph.hash(password)
        return hashed_pass

    #Adds amount of ecopoints to user's ecopoint balance
    def add_ecopoints(self, amount):
        self.ecopoints += amount
        return self.ecopoints

    #Takes away amount of ecopoints to user's ecopoint balance
    def deduct_ecopoints(self, amount):
        self.ecopoints -= amount
        return self.ecopoints

    def calculate_ecopoints(self, last_session_start:datetime, do_add_to_balance=False):
        """
        Calculates ecopoints based on the user's carbon output in the time since the last session.
        :param last_session_start: The start of the user's previous session (*not* the current session)
        :param do_add_to_balance: Whether to add the final ecopoint total to the user's balance or not
        :return: The total ecopoints earned since the last session
        """
        now = datetime.datetime.now()
        #Ecopoints are rewarded to all users every midnight based on how much carbon they used over the past day
        last_midnight = now.date()
        midnight_after_session = last_session_start.date()+(datetime.timedelta(days=1))
        ecopoints = 0
        max_ecopoints = 999

        if last_session_start<last_midnight: #If the user has not already logged in today
            this_day_start = last_session_start #Set the loop's day start to the last session start
            this_day_end = midnight_after_session #Set the loop's day end to the midnight after last session
            while this_day_end < now:  #For every day since last login that isn't today
                #Get User's Carbon Total between start of the day and end of the day
                user_total, user_entries = self.get_carbon_total(this_day_start, this_day_end)
                #Get Global Carbon Total between start of the day and end of the day
                global_total, global_entries = CarbonLog.get_global_carbon_total(this_day_start, this_day_end)
                #Get Global Number of Users who posted logs between start of the day and end of the day
                num_users = global_entries.count(sqlalchemy.distinct(CarbonLog.user_id))

                #'Shift' the loop's day values on by 1
                this_day_start = this_day_end
                this_day_end = this_day_start + datetime.timedelta(days=1)

                #Try add ecopoints
                if user_entries > 0: # If the user didnt log anything, they get nothing. "ohh but i didn't use any carbon!" No you did use carbon its impossible not to stop lying and log it next time
                    try:
                        #Calculated by the proportion of the global carbon total for that day over the user carbon total for that day
                        #The less carbon emitted by the user, the more they obtain, up to a maximum
                        #Currently, the assumed average amount of carbon (20000g, or 20kg) returns 200 ecopoints
                        #This exponentially increases with lower carbon, and exponentially decreases with more carbon
                        #This can be revised if needed
                        ecopoints += min(round((global_total/user_total*num_users)*200),max_ecopoints)
                    except ZeroDivisionError:
                        continue

        if do_add_to_balance:
            self.add_ecopoints(ecopoints)
        return ecopoints

    def email_sent(self):
        return self.verification_email_sent


    def verify_password(self, submitted_password):
        try:
            ph.verify(self.password, submitted_password)
        except VerifyMismatchError:
            return False
        except VerificationError:
            return False
        return True

    #Sends a friend request from this user to the user with friend_user_id
    #Creates a Friend relation with is_request set to 1, and commits it to the database
    #Returns the newly created friend relation
    #Raises AssertionError if the friend relation already exists or if the user attempts to make friends with itself
    def request_friend(self, friend_user_id):
        result = Friend.check_friends(friend_user_id, self.user_id, True)
        assert result is None, "Friend relation already exists"
        if result is None:
            friend = Friend(self.user_id, friend_user_id)
            db.session.add(friend)
            db.session.commit()
            return friend

    #Accepts a friend request for a relation with friend_user_id
    #Sets is_request to 0 and replaces friend_date with the current time
    #Returns the friend relation
    #Raises AssertionError if the friend request doesn't exist, is already accepted, or has been sent by this user
    def accept_friend(self, friend_user_id):
        result = Friend.check_friends(friend_user_id, self.user_id, True)
        assert result is not None, "No friend request exists"
        assert result.is_request is 1, "Friend request already accepted"
        assert result.requested_by is not self.user_id, "Users cannot accept requests that they sent"
        result.is_request = 0
        result.friend_date = datetime.now()
        return result

    def get_carbon_entries(self, start_datetime:datetime=None, end_datetime:datetime=None):
        query = CarbonLog.query.filter_by(user_id=self.user_id)

        if start_datetime:
            query = query.filter(CarbonLog.log_timestamp >= start_datetime)
        if end_datetime:
            query = query.filter(CarbonLog.log_timestamp <= end_datetime)

        return query.all()

    def get_carbon_total(self, start_datetime:datetime=None, end_datetime:datetime=None):
        entries = self.get_carbon_entries(start_datetime, end_datetime)
        total = 0.0
        for entry in entries:
            total+=entry.get_carbon()
        return total, entries



#Address database table class
class Address(db.Model):
    __tablename__ = 'address'

    address_id = db.Column(db.Integer, primary_key=True, nullable=False)#, unsigned=True, unique=True)
    first_line = db.Column(db.String(100), nullable=False)
    second_line = db.Column(db.String(100), nullable=True)
    third_line = db.Column(db.String(100), nullable=True)
    postcode = db.Column(db.String(8), nullable=False)
    city = db.Column(db.String(45), nullable=True)
    region = db.Column(db.String(45), nullable=True)

    #first_line - The first line of the address (e.g. '10 Downing Street')
    #postcode - The postcode of the address (e.g. 'KY12 0AG')
    ## OPTIONAL ARGUMENTS - Define by using `argument_name = [argument_value]` (e.g. second_line='West End')
    #second_line (optional) - The second line of the address
    #third_line (optional) - The third line of the address
    #city (optional) - The city the address is located in (e.g 'Newcastle-upon-Tyne')
    #region (optional) - The region the address is located in (e.g 'Tyne and Wear')
    def __init__(self, first_line, postcode, **kwargs):
        self.first_line = first_line
        self.postcode = postcode
        self.second_line = kwargs.get('second_line', None)
        self.third_line = kwargs.get('third_line', None)
        self.city = kwargs.get('city', None)
        self.region = kwargs.get('region', None)

#Carbon log database table class
class CarbonLog(db.Model):
    __tablename__ = 'carbon_log'

    log_id = db.Column(db.Integer, primary_key=True, nullable=False)#, unique=True, unsigned=True)
    log_timestamp = db.Column(db.DateTime, nullable=False)
    user_id = db.Column(db.Integer, db.ForeignKey('user.user_id'), nullable=False)
    template_type = db.Column(db.Enum(LogTypes), nullable=False)
    template_id = db.Column(db.Integer, db.ForeignKey('journey_template.template_id'), db.ForeignKey('appliance_template.template_id'), nullable=False)
    start_time = db.Column(db.DateTime, nullable=False)
    end_time = db.Column(db.DateTime, nullable=False)
    journey_distance = db.Column(db.DECIMAL, nullable=True)#, unsigned=True)
    carbon_intensities = db.Column(db.JSON, nullable=True)

    #user_id - The user id of the user who registered the log
    #template_type - The type of template used for the log, either trip or appliance (see database.LogTypes)
    #template_id - The template_id of the associated JourneyTemplate or ApplianceTemplate
    #start_time - A datetime of the start of the logged event (e.g. time trip set off, time lightbulb turned on)
    #end_time - A datetime of the end of the logged event (e.g. time trip destination reached, time lightbulb turned off)
    #journey_distance (optional) - A decimal representing the distance of the journey in km. Only needed when template_type is 'trip'.
    def __init__(self, user_id, template_type, template_id, start_time, end_time, **kwargs):
        self.user_id = user_id
        self.log_timestamp = datetime.datetime.now()
        self.template_type = template_type
        self.template_id = template_id
        self.start_time = start_time
        self.end_time = end_time
        self.journey_distance = kwargs.get('journey_distance', None)

    def get_carbon(self):
        """
        Calculates the carbon produced in g from the log
        :return: (float) Amount of carbon produced in g
        """
        carbon = 0.0
        if self.template_type == LogTypes.trip:
            template = JourneyTemplate.query.filter_by(template_id=self.template_id).first()
            carbon = template.carbon_per_km*self.journey_distance
        else:
            if self.carbon_intensities is None:
                self.carbon_intensities = json.loads(neso.request_carbon_intensity(self.start_time, self.end_time))
                db.session.commit()
            template = ApplianceTemplate.query.filter_by(template_id=self.template_id).first()
            for intensity in self.carbon_intensities:
                carbon+=(template.wattage*(60*30)*(1/3600000))*intensity #Energy used in kWh per 30 minutes * carbon intensity for that time
        return carbon

    @staticmethod
    def get_global_carbon_entries(start_datetime:datetime=None, end_datetime:datetime=None):
        if end_datetime is None:
            if start_datetime is None:
                entries = CarbonLog.query.all()
            else:
                entries = db.session.execute(db.select(CarbonLog).where(CarbonLog.log_timestamp>=start_datetime))
        else:
            entries = db.session.execute(db.select(CarbonLog).where(db.and_(CarbonLog.log_timestamp>=start_datetime,CarbonLog.log_timestamp<=end_datetime)))

        return entries

    @staticmethod
    def get_global_carbon_total(start_datetime:datetime=None, end_datetime:datetime=None):
        entries = CarbonLog.get_global_carbon_entries(start_datetime, end_datetime)
        total=0.0
        for entry in entries:
            total+=entry.get_carbon()
        return total, entries

#Journey Transport Mode Template database table class
#Is a 'template' for a mode of transport defined by the user, allowing them to create logs based on it
#E.g., A user defines the name, and amount of carbon emitted by their car per km
class JourneyTemplate(db.Model):
    __tablename__ = 'journey_template'
    template_id = db.Column(db.Integer, primary_key=True, nullable=False)#, unique=True, unsigned=True)
    template_name = db.Column(db.String(45), nullable=False)
    carbon_per_km = db.Column(db.DECIMAL, nullable=False)#, unsigned=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.user_id'), nullable=False)
    is_public = db.Column(db.Boolean, nullable=False)#, default=False)

    #mode_name - User-defined name of the transport template (e.g. 'My Car')
    #carbon_per_km - Decimal value, User-defined amount of carbon in grams emitted by the mode per km
    #user_id - The user id of the user who created the journey mode template.
    #is_public - If the template can be viewed by all users or not. This should be false unless it is a general, public template created by an admin.
    def __init__(self, template_name, carbon_per_km, user_id, is_public=False):
        self.template_name = template_name
        self.carbon_per_km = carbon_per_km
        self.user_id = user_id
        self.is_public = is_public

    @staticmethod
    def calculate_carbon_per_km(fuel_consumption, fuel_type:FuelTypes=None, **kwargs):
        """
        Takes details of a user's vehicle and calculates the carbon per km
        :param fuel_consumption: The fuel consumption of vehicle in litres per 100 km
        :param fuel_type: The fuel type, either petrol or diesel; see enums.FuelTypes
        :param kwargs: carbon_per_litre: The amount of carbon produced per litre of fuel if fuel_type is unspecified
        :return: the amount of carbon produced per km
        """
        if fuel_type is None:
            carbon_per_litre = kwargs.get('carbon_per_litre')
        elif fuel_type == FuelTypes(0): #Petrol
            carbon_per_litre = 2540
        elif fuel_type == FuelTypes(1): #Diesel
            carbon_per_litre = 2310
        else:
            raise ValueError("fuel_type or carbon_per_litre must be specified")
        return float((fuel_consumption/100) * carbon_per_litre)



#Appliance Template database table class
#Is a 'template' for a single type of appliance defined by the user, allowing them to create logs based on it
#E.g., A user defines the name and wattage of their washing machine
class ApplianceTemplate(db.Model):
    __tablename__ = 'appliance_template'
    template_id = db.Column(db.Integer, primary_key=True, nullable=False)#, unique=True, unsigned=True)
    template_name = db.Column(db.String(45), nullable=False)
    wattage = db.Column(db.DECIMAL, nullable=False)#, unsigned=True)
    user_id = db.Column(db.Integer, db.ForeignKey('user.user_id'), nullable=False)
    is_public = db.Column(db.Boolean, nullable=False)#, default=False)

    #appliance_name - User-defined name of the appliance template (e.g. 'My Washing Machine')
    #wattage - Decimal value, User-defined wattage of the appliance (energy in J used per second) in W
    #user_id - The user id of the user who created the appliance template
    #is_public - If the template can be viewed by all users or not. This should be false unless it is a general, public template created by an admin.
    def __init__(self, template_name, wattage, user_id, is_public=False):
        self.template_name = template_name
        self.wattage = wattage
        self.user_id = user_id
        self.is_public = is_public


class Friend(db.Model):
    __tablename__ = 'friend'
    user_id_1 = db.Column(db.Integer, db.ForeignKey('user.user_id'), primary_key=True, nullable=False)
    user_id_2 = db.Column(db.Integer, db.ForeignKey('user.user_id'), primary_key=True, nullable=False)
    is_request = db.Column(db.Boolean, nullable=False)#, default=1)
    friend_date = db.Column(db.DateTime, nullable=False)
    requested_by = db.Column(db.Integer, db.ForeignKey('user.user_id'), nullable=False)

    #user_id_1 - user_id of a user
    #user_id_2 - user_id of a different user
    #requested_by - user_id of the user who sent the friend request, defaults to user_id_1.
    #Raises AssertionError if the user_id_1 == user_id_2
    ## NOTE: please avoid explicitly creating a friend relation with this init constructor; use User.request_friend() instead
    def __init__(self, user_id_1, user_id_2, requested_by=user_id_1):
        assert user_id_1 is not user_id_2, "User cannot send friend request to itself"
        ordered_ids = Friend._order_ids(user_id_1, user_id_2)
        self.user_id_1 = ordered_ids[0]
        self.user_id_2 = ordered_ids[1]
        self.requested_by = requested_by
        self.is_request = 1
        self.friend_date = datetime.now()

    #Private method; orders two user ids for valid operation
    #For operation to be valid in the friend table, user_id_1 must be smaller than user_id_2
    @staticmethod
    def _order_ids(user_id_1: int, user_id_2: int) -> object:
        output = [user_id_1, user_id_2]
        output.sort()
        return output

    #Checks if user_id_1 and user_id_2 are friends.
    #By default, this function will ignore friend requests. Use include_request=True to allow friend requests to be returned
    #Returns the friend relation if it exists, else returns None
    @staticmethod
    def check_friends(user_id_1, user_id_2, include_request=False):
        friend = Friend._order_ids(user_id_1, user_id_2)
        result = db.session.execute(
            db.select(Friend).where(Friend.user_id_1==friend[0],Friend.user_id_2==friend[1])
        ).first()
        if result:
            if include_request or result.is_request==0:
                return result
        return None

#TODO: Implement solar tracking
#TODO: Implement testing
